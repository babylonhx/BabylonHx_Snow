package com.babylonhx.materials;

/**
 * ...
 * @author Krtolica Vujadin
 */
@:expose('BABYLON.ShadersStore') class ShadersStore {

	//public static var Shaders:Map<String, String> = new Map<String, String>();
	public static var Shaders:Map<String, String> = [
		"anaglyph.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D leftSampler;\r\n\r\nvoid main(void)\r\n{\r\nvec4 leftFrag = texture2D(leftSampler, vUV);\r\nleftFrag = vec4(1.0, leftFrag.g, leftFrag.b, 1.0);\r\n\r\nvec4 rightFrag = texture2D(textureSampler, vUV);\r\nrightFrag = vec4(rightFrag.r, 1.0, 1.0, 1.0);\r\n\r\ngl_FragColor = vec4(rightFrag.rgb * leftFrag.rgb, 1.0);\r\n}",
		"blackAndWhite.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nvoid main(void)\r\n{\r\nfloat luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));\r\ngl_FragColor = vec4(luminance, luminance, luminance, 1.0);\r\n}",
		"blur.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec2 screenSize;\r\nuniform vec2 direction;\r\nuniform float blurWidth;\r\n\r\nvoid main(void)\r\n{\r\nfloat weights[7];\r\nweights[0] = 0.05;\r\nweights[1] = 0.1;\r\nweights[2] = 0.2;\r\nweights[3] = 0.3;\r\nweights[4] = 0.2;\r\nweights[5] = 0.1;\r\nweights[6] = 0.05;\r\n\r\nvec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\r\nvec2 texelStep = texelSize * direction * blurWidth;\r\nvec2 start = vUV - 3.0 * texelStep;\r\n\r\nvec4 baseColor = vec4(0., 0., 0., 0.);\r\nvec2 texelOffset = vec2(0., 0.);\r\n\r\nfor (int i = 0; i < 7; i++)\r\n{\r\nbaseColor += texture2D(textureSampler, start + texelOffset) * weights[i];\r\ntexelOffset += texelStep;\r\n}\r\n\r\ngl_FragColor = baseColor;\r\n}",
		"brick.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nuniform float numberOfBricksHeight;\r\nuniform float numberOfBricksWidth;\r\nuniform vec3 brickColor;\r\nuniform vec3 jointColor;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nfloat round(float number){\r\nreturn sign(number)*floor(abs(number) + 0.5);\r\n}\r\n\r\nvoid main(void)\r\n{\r\nfloat brickW = 1.0 / numberOfBricksWidth;\r\nfloat brickH = 1.0 / numberOfBricksHeight;\r\nfloat jointWPercentage = 0.01;\r\nfloat jointHPercentage = 0.05;\r\nvec3 color = brickColor;\r\nfloat yi = vUV.y / brickH;\r\nfloat nyi = round(yi);\r\nfloat xi = vUV.x / brickW;\r\n\r\nif (mod(floor(yi), 2.0) == 0.0){\r\nxi = xi - 0.5;\r\n}\r\n\r\nfloat nxi = round(xi);\r\nvec2 brickvUV = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) /  brickW);\r\n\r\nif (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\r\ncolor = mix(jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\r\n}\r\nelse if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\r\ncolor = mix(jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\r\n}\r\nelse {\r\nfloat brickColorSwitch = mod(floor(yi) + floor(xi), 3.0);\r\n\r\nif (brickColorSwitch == 0.0)\r\ncolor = mix(color, vec3(0.33, 0.33, 0.33), 0.3);\r\nelse if (brickColorSwitch == 2.0)\r\ncolor = mix(color, vec3(0.11, 0.11, 0.11), 0.3);\r\n}\r\n\r\ngl_FragColor = vec4(color, 1.0);\r\n}",
		"chromaticAberration.fragment" => "\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform sampler2D textureSampler; // original color\r\n\r\nuniform float chromatic_aberration;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void)\r\n{\r\nvec2 centered_screen_pos = vec2(vUV.x - 0.5, vUV.y - 0.5);\r\nfloat radius2 = centered_screen_pos.x*centered_screen_pos.x\r\n+ centered_screen_pos.y*centered_screen_pos.y;\r\nfloat radius = sqrt(radius2);\r\n\r\nvec4 original = texture2D(textureSampler, vUV);\r\n\r\nif (chromatic_aberration > 0.0) {\r\nvec3 ref_indices = vec3(-0.3, 0.0, 0.3);\r\nfloat ref_shiftX = chromatic_aberration * radius * 17.0 / screen_width;\r\nfloat ref_shiftY = chromatic_aberration * radius * 17.0 / screen_height;\r\n\r\nvec2 ref_coords_r = vec2(vUV.x + ref_indices.r*ref_shiftX, vUV.y + ref_indices.r*ref_shiftY*0.5);\r\nvec2 ref_coords_g = vec2(vUV.x + ref_indices.g*ref_shiftX, vUV.y + ref_indices.g*ref_shiftY*0.5);\r\nvec2 ref_coords_b = vec2(vUV.x + ref_indices.b*ref_shiftX, vUV.y + ref_indices.b*ref_shiftY*0.5);\r\n\r\noriginal.r = texture2D(textureSampler, ref_coords_r).r;\r\noriginal.g = texture2D(textureSampler, ref_coords_g).g;\r\noriginal.b = texture2D(textureSampler, ref_coords_b).b;\r\n}\r\n\r\ngl_FragColor = original;\r\n}",
		"cloud.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\n\r\nuniform vec3 skyColor;\r\nuniform vec3 cloudColor;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nvoid main() {\r\n\r\nvec2 p = vUV * 12.0;\r\nvec3 c = mix(skyColor, cloudColor, fbm(p));\r\ngl_FragColor = vec4(c, 1);\r\n\r\n}",
		"color.fragment" => "precision highp float;\r\n\r\nuniform vec4 color;\r\n\r\nvoid main(void) {\r\ngl_FragColor = color;\r\n}",
		"color.vertex" => "precision highp float;\r\n\r\nattribute vec3 position;\r\n\r\nuniform mat4 worldViewProjection;\r\n\r\nvoid main(void) {\r\ngl_Position = worldViewProjection * vec4(position, 1.0);\r\n}",
		"colorCorrection.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform sampler2D textureSampler; // screen render\r\nuniform sampler2D colorTable; // color table with modified colors\r\n\r\nvarying vec2 vUV;\r\n\r\nconst float SLICE_COUNT = 16.0; // how many slices in the color cube; 1 slice = 1 pixel\r\n\r\nvec4 sampleAs3DTexture(sampler2D texture, vec3 uv, float width) {\r\nfloat sliceSize = 1.0 / width;              // space of 1 slice\r\nfloat slicePixelSize = sliceSize / width;           // space of 1 pixel\r\nfloat sliceInnerSize = slicePixelSize * (width - 1.0);  // space of width pixels\r\nfloat zSlice0 = min(floor(uv.z * width), width - 1.0);\r\nfloat zSlice1 = min(zSlice0 + 1.0, width - 1.0);\r\nfloat xOffset = slicePixelSize * 0.5 + uv.x * sliceInnerSize;\r\nfloat s0 = xOffset + (zSlice0 * sliceSize);\r\nfloat s1 = xOffset + (zSlice1 * sliceSize);\r\nvec4 slice0Color = texture2D(texture, vec2(s0, uv.y));\r\nvec4 slice1Color = texture2D(texture, vec2(s1, uv.y));\r\nfloat zOffset = mod(uv.z * width, 1.0);\r\nvec4 result = mix(slice0Color, slice1Color, zOffset);\r\nreturn result;\r\n}\r\n\r\nvoid main(void)\r\n{\r\nvec4 screen_color = texture2D(textureSampler, vUV);\r\ngl_FragColor = sampleAs3DTexture(colorTable, screen_color.rgb, SLICE_COUNT);\r\n\r\n}",
		"convolution.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec2 screenSize;\r\nuniform float kernel[9];\r\n\r\nvoid main(void)\r\n{\r\nvec2 onePixel = vec2(1.0, 1.0) / screenSize;\r\nvec4 colorSum =\r\ntexture2D(textureSampler, vUV + onePixel * vec2(-1, -1)) * kernel[0] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(0, -1)) * kernel[1] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(1, -1)) * kernel[2] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(-1, 0)) * kernel[3] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(0, 0)) * kernel[4] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(1, 0)) * kernel[5] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(-1, 1)) * kernel[6] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(0, 1)) * kernel[7] +\r\ntexture2D(textureSampler, vUV + onePixel * vec2(1, 1)) * kernel[8];\r\n\r\nfloat kernelWeight =\r\nkernel[0] +\r\nkernel[1] +\r\nkernel[2] +\r\nkernel[3] +\r\nkernel[4] +\r\nkernel[5] +\r\nkernel[6] +\r\nkernel[7] +\r\nkernel[8];\r\n\r\nif (kernelWeight <= 0.0) {\r\nkernelWeight = 1.0;\r\n}\r\n\r\ngl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);\r\n}",
		"default.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define MAP_EXPLICIT 0.\r\n#define MAP_SPHERICAL 1.\r\n#define MAP_PLANAR 2.\r\n#define MAP_CUBIC 3.\r\n#define MAP_PROJECTION 4.\r\n#define MAP_SKYBOX 5.\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vAmbientColor;\r\nuniform vec4 vDiffuseColor;\r\nuniform vec4 vSpecularColor;\r\nuniform vec3 vEmissiveColor;\r\n\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef LIGHT0\r\nuniform vec4 vLightData0;\r\nuniform vec4 vLightDiffuse0;\r\nuniform vec3 vLightSpecular0;\r\n#ifdef SHADOW0\r\nvarying vec4 vPositionFromLight0;\r\nuniform sampler2D shadowSampler0;\r\nuniform vec3 shadowsInfo0;\r\n#endif\r\n#ifdef SPOTLIGHT0\r\nuniform vec4 vLightDirection0;\r\n#endif\r\n#ifdef HEMILIGHT0\r\nuniform vec3 vLightGround0;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT1\r\nuniform vec4 vLightData1;\r\nuniform vec4 vLightDiffuse1;\r\nuniform vec3 vLightSpecular1;\r\n#ifdef SHADOW1\r\nvarying vec4 vPositionFromLight1;\r\nuniform sampler2D shadowSampler1;\r\nuniform vec3 shadowsInfo1;\r\n#endif\r\n#ifdef SPOTLIGHT1\r\nuniform vec4 vLightDirection1;\r\n#endif\r\n#ifdef HEMILIGHT1\r\nuniform vec3 vLightGround1;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT2\r\nuniform vec4 vLightData2;\r\nuniform vec4 vLightDiffuse2;\r\nuniform vec3 vLightSpecular2;\r\n#ifdef SHADOW2\r\nvarying vec4 vPositionFromLight2;\r\nuniform sampler2D shadowSampler2;\r\nuniform vec3 shadowsInfo2;\r\n#endif\r\n#ifdef SPOTLIGHT2\r\nuniform vec4 vLightDirection2;\r\n#endif\r\n#ifdef HEMILIGHT2\r\nuniform vec3 vLightGround2;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT3\r\nuniform vec4 vLightData3;\r\nuniform vec4 vLightDiffuse3;\r\nuniform vec3 vLightSpecular3;\r\n#ifdef SHADOW3\r\nvarying vec4 vPositionFromLight3;\r\nuniform sampler2D shadowSampler3;\r\nuniform vec3 shadowsInfo3;\r\n#endif\r\n#ifdef SPOTLIGHT3\r\nuniform vec4 vLightDirection3;\r\n#endif\r\n#ifdef HEMILIGHT3\r\nuniform vec3 vLightGround3;\r\n#endif\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform sampler2D diffuseSampler;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform sampler2D ambientSampler;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvarying vec2 vOpacityUV;\r\nuniform sampler2D opacitySampler;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform sampler2D specularSampler;\r\n#endif\r\n\r\n#ifdef FRESNEL\r\nfloat computeFresnelTerm(vec3 viewDirection, vec3 worldNormal, float bias, float power)\r\n{\r\nfloat fresnelTerm = pow(bias + abs(dot(viewDirection, worldNormal)), power);\r\nreturn clamp(fresnelTerm, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifdef DIFFUSEFRESNEL\r\nuniform vec4 diffuseLeftColor;\r\nuniform vec4 diffuseRightColor;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\nuniform vec4 opacityParts;\r\n#endif\r\n\r\n#ifdef REFLECTIONFRESNEL\r\nuniform vec4 reflectionLeftColor;\r\nuniform vec4 reflectionRightColor;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nuniform vec4 emissiveLeftColor;\r\nuniform vec4 emissiveRightColor;\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nvarying vec3 vPositionUVW;\r\nuniform samplerCube reflectionCubeSampler;\r\nuniform sampler2D reflection2DSampler;\r\nuniform vec3 vReflectionInfos;\r\nuniform mat4 reflectionMatrix;\r\nuniform mat4 view;\r\n\r\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\r\n{\r\nif (mode == MAP_SPHERICAL)\r\n{\r\nvec3 coords = vec3(view * vec4(worldNormal, 0.0));\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 1.0));\r\n}\r\nelse if (mode == MAP_PLANAR)\r\n{\r\nvec3 viewDir = worldPos.xyz - vEyePosition;\r\nvec3 coords = normalize(reflect(viewDir, worldNormal));\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 1));\r\n}\r\nelse if (mode == MAP_CUBIC)\r\n{\r\nvec3 viewDir = worldPos.xyz - vEyePosition;\r\nvec3 coords = reflect(viewDir, worldNormal);\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 0));\r\n}\r\nelse if (mode == MAP_PROJECTION)\r\n{\r\nreturn vec3(reflectionMatrix * (view * worldPos));\r\n}\r\nelse if (mode == MAP_SKYBOX)\r\n{\r\nreturn vPositionUVW;\r\n}\r\n\r\nreturn vec3(0, 0, 0);\r\n}\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n\r\nfloat unpack(vec4 color)\r\n{\r\nconst vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\nreturn dot(color, bit_shift);\r\n}\r\n\r\nfloat unpackHalf(vec2 color)\r\n{\r\nreturn color.x + (color.y / 255.0);\r\n}\r\n\r\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)\r\n{\r\nvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\ndepth = 0.5 * depth + vec3(0.5);\r\nvec2 uv = depth.xy;\r\n\r\nif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nfloat shadow = unpack(texture2D(shadowSampler, uv)) + bias;\r\n\r\nif (depth.z > shadow)\r\n{\r\nreturn darkness;\r\n}\r\nreturn 1.;\r\n}\r\n\r\nfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler, float mapSize, float bias)\r\n{\r\nvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\ndepth = 0.5 * depth + vec3(0.5);\r\nvec2 uv = depth.xy;\r\n\r\nif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nfloat visibility = 1.;\r\n\r\nvec2 poissonDisk[4];\r\npoissonDisk[0] = vec2(-0.94201624, -0.39906216);\r\npoissonDisk[1] = vec2(0.94558609, -0.76890725);\r\npoissonDisk[2] = vec2(-0.094184101, -0.92938870);\r\npoissonDisk[3] = vec2(0.34495938, 0.29387760);\r\n\r\nfloat biasedDepth = depth.z - bias;\r\n\r\nif (unpack(texture2D(shadowSampler, uv + poissonDisk[0] / mapSize)) < biasedDepth) visibility -= 0.25;\r\nif (unpack(texture2D(shadowSampler, uv + poissonDisk[1] / mapSize)) < biasedDepth) visibility -= 0.25;\r\nif (unpack(texture2D(shadowSampler, uv + poissonDisk[2] / mapSize)) < biasedDepth) visibility -= 0.25;\r\nif (unpack(texture2D(shadowSampler, uv + poissonDisk[3] / mapSize)) < biasedDepth) visibility -= 0.25;\r\n\r\nreturn visibility;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\nreturn clamp((v - low) / (high - low), 0.0, 1.0);\r\n}\r\n\r\nfloat ChebychevInequality(vec2 moments, float compare, float bias)\r\n{\r\nfloat p = smoothstep(compare - bias, compare, moments.x);\r\nfloat variance = max(moments.y - moments.x * moments.x, 0.02);\r\nfloat d = compare - moments.x;\r\nfloat p_max = linstep(0.2, 1.0, variance / (variance + d * d));\r\n\r\nreturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler, float bias)\r\n{\r\nvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\ndepth = 0.5 * depth + vec3(0.5);\r\nvec2 uv = depth.xy;\r\n\r\nif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0 || depth.z >= 1.0)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nvec4 texel = texture2D(shadowSampler, uv);\r\n\r\nvec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\r\nreturn 1.0 - ChebychevInequality(moments, depth.z, bias);\r\n}\r\n#endif\r\n\r\n#ifdef BUMP\r\n#extension GL_OES_standard_derivatives : enable\r\nvarying vec2 vBumpUV;\r\nuniform vec2 vBumpInfos;\r\nuniform sampler2D bumpSampler;\r\n\r\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\r\n{\r\nvec3 dp1 = dFdx(p);\r\nvec3 dp2 = dFdy(p);\r\nvec2 duv1 = dFdx(uv);\r\nvec2 duv2 = dFdy(uv);\r\n\r\nvec3 dp2perp = cross(dp2, normal);\r\nvec3 dp1perp = cross(normal, dp1);\r\nvec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\r\nvec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\r\n\r\nfloat invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\r\nreturn mat3(tangent * invmax, binormal * invmax, normal);\r\n}\r\n\r\nvec3 perturbNormal(vec3 viewDir)\r\n{\r\nvec3 map = texture2D(bumpSampler, vBumpUV).xyz;\r\nmap = map * 255. / 127. - 128. / 127.;\r\nmat3 TBN = cotangent_frame(vNormalW * vBumpInfos.y, -viewDir, vBumpUV);\r\nreturn normalize(TBN * map);\r\n}\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n#ifdef FOG\r\n\r\n#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform vec4 vFogInfos;\r\nuniform vec3 vFogColor;\r\nvarying float fFogDistance;\r\n\r\nfloat CalcFogFactor()\r\n{\r\nfloat fogCoeff = 1.0;\r\nfloat fogStart = vFogInfos.y;\r\nfloat fogEnd = vFogInfos.z;\r\nfloat fogDensity = vFogInfos.w;\r\n\r\nif (FOGMODE_LINEAR == vFogInfos.x)\r\n{\r\nfogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\r\n}\r\nelse if (FOGMODE_EXP == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\r\n}\r\nelse if (FOGMODE_EXP2 == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\r\n}\r\n\r\nreturn clamp(fogCoeff, 0.0, 1.0);\r\n}\r\n#endif\r\n\r\nstruct lightingInfo\r\n{\r\nvec3 diffuse;\r\nvec3 specular;\r\n};\r\n\r\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range) {\r\nlightingInfo result;\r\n\r\nvec3 lightVectorW;\r\nfloat attenuation = 1.0;\r\nif (lightData.w == 0.)\r\n{\r\nvec3 direction = lightData.xyz - vPositionW;\r\n\r\nattenuation = max(0., 1.0 - length(direction) / range);\r\nlightVectorW = normalize(direction);\r\n}\r\nelse\r\n{\r\nlightVectorW = normalize(-lightData.xyz);\r\n}\r\n\r\nfloat ndl = max(0., dot(vNormal, lightVectorW));\r\n\r\nvec3 angleW = normalize(viewDirectionW + lightVectorW);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = pow(specComp, max(1., vSpecularColor.a));\r\n\r\nresult.diffuse = ndl * diffuseColor * attenuation;\r\nresult.specular = specComp * specularColor * attenuation;\r\n\r\nreturn result;\r\n}\r\n\r\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range) {\r\nlightingInfo result;\r\n\r\nvec3 direction = lightData.xyz - vPositionW;\r\nvec3 lightVectorW = normalize(direction);\r\nfloat attenuation = max(0., 1.0 - length(direction) / range);\r\n\r\nfloat cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\r\nfloat spotAtten = 0.0;\r\n\r\nif (cosAngle >= lightDirection.w)\r\n{\r\ncosAngle = max(0., pow(cosAngle, lightData.w));\r\nspotAtten = clamp((cosAngle - lightDirection.w) / (1. - cosAngle), 0.0, 1.0);\r\n\r\nfloat ndl = max(0., dot(vNormal, -lightDirection.xyz));\r\n\r\nvec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = pow(specComp, vSpecularColor.a);\r\n\r\nresult.diffuse = ndl * spotAtten * diffuseColor * attenuation;\r\nresult.specular = specComp * specularColor * spotAtten * attenuation;\r\n\r\nreturn result;\r\n}\r\n\r\nresult.diffuse = vec3(0.);\r\nresult.specular = vec3(0.);\r\n\r\nreturn result;\r\n}\r\n\r\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor) {\r\nlightingInfo result;\r\n\r\nfloat ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\r\n\r\nvec3 angleW = normalize(viewDirectionW + lightData.xyz);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = pow(specComp, vSpecularColor.a);\r\n\r\nresult.diffuse = mix(groundColor, diffuseColor, ndl);\r\nresult.specular = specComp * specularColor;\r\n\r\nreturn result;\r\n}\r\n\r\nvoid main(void) {\r\n#ifdef CLIPPLANE\r\nif (fClipDistance > 0.0)\r\ndiscard;\r\n#endif\r\n\r\nvec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\nvec4 baseColor = vec4(1., 1., 1., 1.);\r\nvec3 diffuseColor = vDiffuseColor.rgb;\r\n\r\nfloat alpha = vDiffuseColor.a;\r\n\r\n#ifdef VERTEXCOLOR\r\nbaseColor.rgb *= vColor.rgb;\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nbaseColor = texture2D(diffuseSampler, vDiffuseUV);\r\n\r\n#ifdef ALPHATEST\r\nif (baseColor.a < 0.4)\r\ndiscard;\r\n#endif\r\n\r\n#ifdef ALPHAFROMDIFFUSE\r\nalpha *= baseColor.a;\r\n#endif\r\n\r\nbaseColor.rgb *= vDiffuseInfos.y;\r\n#endif\r\n\r\n#ifdef NORMAL\r\nvec3 normalW = normalize(vNormalW);\r\n#else\r\nvec3 normalW = vec3(1.0, 1.0, 1.0);\r\n#endif\r\n\r\n\r\n#ifdef BUMP\r\nnormalW = perturbNormal(viewDirectionW);\r\n#endif\r\n\r\n\r\nvec3 baseAmbientColor = vec3(1., 1., 1.);\r\n\r\n#ifdef AMBIENT\r\nbaseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\r\n#endif\r\n\r\nvec3 diffuseBase = vec3(0., 0., 0.);\r\nvec3 specularBase = vec3(0., 0., 0.);\r\nfloat shadow = 1.;\r\n\r\n#ifdef LIGHT0\r\n#ifdef SPOTLIGHT0\r\nlightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\r\n#endif\r\n#ifdef HEMILIGHT0\r\nlightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0);\r\n#endif\r\n#ifdef POINTDIRLIGHT0\r\nlightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\r\n#endif\r\n#ifdef SHADOW0\r\n#ifdef SHADOWVSM0\r\nshadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0, shadowsInfo0.z);\r\n#else\r\n#ifdef SHADOWPCF0\r\nshadow = computeShadowWithPCF(vPositionFromLight0, shadowSampler0, shadowsInfo0.y, shadowsInfo0.z);\r\n#else\r\nshadow = computeShadow(vPositionFromLight0, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);\r\n#endif\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info.diffuse * shadow;\r\nspecularBase += info.specular * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT1\r\n#ifdef SPOTLIGHT1\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\r\n#endif\r\n#ifdef HEMILIGHT1\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1);\r\n#endif\r\n#ifdef POINTDIRLIGHT1\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\r\n#endif\r\n#ifdef SHADOW1\r\n#ifdef SHADOWVSM1\r\nshadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1, shadowsInfo1.z);\r\n#else\r\n#ifdef SHADOWPCF1\r\nshadow = computeShadowWithPCF(vPositionFromLight1, shadowSampler1, shadowsInfo1.y, shadowsInfo1.z);\r\n#else\r\nshadow = computeShadow(vPositionFromLight1, shadowSampler1, shadowsInfo1.x, shadowsInfo1.z);\r\n#endif\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info.diffuse * shadow;\r\nspecularBase += info.specular * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT2\r\n#ifdef SPOTLIGHT2\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\r\n#endif\r\n#ifdef HEMILIGHT2\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2);\r\n#endif\r\n#ifdef POINTDIRLIGHT2\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\r\n#endif\r\n#ifdef SHADOW2\r\n#ifdef SHADOWVSM2\r\nshadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2, shadowsInfo2.z);\r\n#else\r\n#ifdef SHADOWPCF2\r\nshadow = computeShadowWithPCF(vPositionFromLight2, shadowSampler2, shadowsInfo2.y, shadowsInfo2.z);\r\n#else\r\nshadow = computeShadow(vPositionFromLight2, shadowSampler2, shadowsInfo2.x, shadowsInfo2.z);\r\n#endif\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info.diffuse * shadow;\r\nspecularBase += info.specular * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT3\r\n#ifdef SPOTLIGHT3\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\r\n#endif\r\n#ifdef HEMILIGHT3\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3);\r\n#endif\r\n#ifdef POINTDIRLIGHT3\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\r\n#endif\r\n#ifdef SHADOW3\r\n#ifdef SHADOWVSM3\r\nshadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3, shadowsInfo3.z);\r\n#else\r\n#ifdef SHADOWPCF3\r\nshadow = computeShadowWithPCF(vPositionFromLight3, shadowSampler3, shadowsInfo3.y, shadowsInfo3.z);\r\n#else\r\nshadow = computeShadow(vPositionFromLight3, shadowSampler3, shadowsInfo3.x, shadowsInfo3.z);\r\n#endif\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info.diffuse * shadow;\r\nspecularBase += info.specular * shadow;\r\n#endif\r\n\r\nvec3 reflectionColor = vec3(0., 0., 0.);\r\n\r\n#ifdef REFLECTION\r\nvec3 vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), normalW);\r\n\r\nif (vReflectionInfos.z != 0.0)\r\n{\r\nreflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y * shadow;\r\n}\r\nelse\r\n{\r\nvec2 coords = vReflectionUVW.xy;\r\n\r\nif (vReflectionInfos.x == MAP_PROJECTION)\r\n{\r\ncoords /= vReflectionUVW.z;\r\n}\r\n\r\ncoords.y = 1.0 - coords.y;\r\n\r\nreflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y * shadow;\r\n}\r\n\r\n#ifdef REFLECTIONFRESNEL\r\nfloat reflectionFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, reflectionRightColor.a, reflectionLeftColor.a);\r\n\r\nreflectionColor *= reflectionLeftColor.rgb * (1.0 - reflectionFresnelTerm) + reflectionFresnelTerm * reflectionRightColor.rgb;\r\n#endif\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\r\n\r\n#ifdef OPACITYRGB\r\nopacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\r\nalpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\r\n#else\r\nalpha *= opacityMap.a * vOpacityInfos.y;\r\n#endif\r\n\r\n#endif\r\n\r\n#ifdef VERTEXALPHA\r\nalpha *= vColor.a;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\nfloat opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\r\n\r\nalpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\r\n#endif\r\n\r\nvec3 emissiveColor = vEmissiveColor;\r\n#ifdef EMISSIVE\r\nemissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nfloat emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\r\n\r\nemissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\r\n#endif\r\n\r\nvec3 specularColor = vSpecularColor.rgb;\r\n#ifdef SPECULAR\r\nspecularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\r\n#endif\r\n\r\n#ifdef DIFFUSEFRESNEL\r\nfloat diffuseFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, diffuseRightColor.a, diffuseLeftColor.a);\r\n\r\ndiffuseBase *= diffuseLeftColor.rgb * (1.0 - diffuseFresnelTerm) + diffuseFresnelTerm * diffuseRightColor.rgb;\r\n#endif\r\n\r\nvec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\r\nvec3 finalSpecular = specularBase * specularColor;\r\n\r\n#ifdef SPECULAROVERALPHA\r\nalpha = clamp(alpha + dot(finalSpecular, vec3(0.3, 0.59, 0.11)), 0., 1.);\r\n#endif\r\n\r\nvec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\r\n\r\n#ifdef FOG\r\nfloat fog = CalcFogFactor();\r\ncolor.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\r\n#endif\r\n\r\ngl_FragColor = color;\r\n}",
		"default.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#ifdef VERTEXCOLOR\r\nattribute vec4 color;\r\n#endif\r\n#ifdef BONES\r\nattribute vec4 matricesIndices;\r\nattribute vec4 matricesWeights;\r\n#endif\r\n\r\n\r\n#ifdef INSTANCES\r\nattribute vec4 world0;\r\nattribute vec4 world1;\r\nattribute vec4 world2;\r\nattribute vec4 world3;\r\n#else\r\nuniform mat4 world;\r\n#endif\r\n\r\nuniform mat4 view;\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform mat4 ambientMatrix;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvarying vec2 vOpacityUV;\r\nuniform mat4 opacityMatrix;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform mat4 specularMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nvarying vec2 vBumpUV;\r\nuniform vec2 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#ifdef BONES\r\nuniform mat4 mBones[BonesPerMesh];\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nuniform vec4 vClipPlane;\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n#ifdef FOG\r\nvarying float fFogDistance;\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n#ifdef LIGHT0\r\nuniform mat4 lightMatrix0;\r\nvarying vec4 vPositionFromLight0;\r\n#endif\r\n#ifdef LIGHT1\r\nuniform mat4 lightMatrix1;\r\nvarying vec4 vPositionFromLight1;\r\n#endif\r\n#ifdef LIGHT2\r\nuniform mat4 lightMatrix2;\r\nvarying vec4 vPositionFromLight2;\r\n#endif\r\n#ifdef LIGHT3\r\nuniform mat4 lightMatrix3;\r\nvarying vec4 vPositionFromLight3;\r\n#endif\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nvarying vec3 vPositionUVW;\r\n#endif\r\n\r\nvoid main(void) {\r\nmat4 finalWorld;\r\n\r\n#ifdef REFLECTION\r\nvPositionUVW = position;\r\n#endif\r\n\r\n#ifdef INSTANCES\r\nfinalWorld = mat4(world0, world1, world2, world3);\r\n#else\r\nfinalWorld = world;\r\n#endif\r\n\r\n#ifdef BONES\r\nmat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\r\nmat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\r\nmat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\r\n\r\n#ifdef BONES4\r\nmat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\r\nfinalWorld = finalWorld * (m0 + m1 + m2 + m3);\r\n#else\r\nfinalWorld = finalWorld * (m0 + m1 + m2);\r\n#endif\r\n\r\n#endif\r\ngl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n\r\nvec4 worldPos = finalWorld * vec4(position, 1.0);\r\nvPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\nvNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\r\n#endif\r\n\r\n#ifndef UV1\r\nvec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\nvec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nif (vDiffuseInfos.x == 0.)\r\n{\r\nvDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nif (vAmbientInfos.x == 0.)\r\n{\r\nvAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef OPACITY\r\nif (vOpacityInfos.x == 0.)\r\n{\r\nvOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nif (vEmissiveInfos.x == 0.)\r\n{\r\nvEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nif (vSpecularInfos.x == 0.)\r\n{\r\nvSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef BUMP\r\nif (vBumpInfos.x == 0.)\r\n{\r\nvBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nfClipDistance = dot(worldPos, vClipPlane);\r\n#endif\r\n\r\n#ifdef FOG\r\nfFogDistance = (view * worldPos).z;\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n#ifdef LIGHT0\r\nvPositionFromLight0 = lightMatrix0 * worldPos;\r\n#endif\r\n#ifdef LIGHT1\r\nvPositionFromLight1 = lightMatrix1 * worldPos;\r\n#endif\r\n#ifdef LIGHT2\r\nvPositionFromLight2 = lightMatrix2 * worldPos;\r\n#endif\r\n#ifdef LIGHT3\r\nvPositionFromLight3 = lightMatrix3 * worldPos;\r\n#endif\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvColor = color;\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\ngl_PointSize = pointSize;\r\n#endif\r\n}",
		"depth.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nuniform float far;\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ALPHATEST\r\nif (texture2D(diffuseSampler, vUV).a < 0.4)\r\ndiscard;\r\n#endif\r\n\r\nfloat depth = (gl_FragCoord.z / gl_FragCoord.w) / far;\r\ngl_FragColor = vec4(depth, depth * depth, 0.0, 1.0);\r\n}",
		"depth.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\n#ifdef BONES\r\nattribute vec4 matricesIndices;\r\nattribute vec4 matricesWeights;\r\n#endif\r\n\r\n#ifdef INSTANCES\r\nattribute vec4 world0;\r\nattribute vec4 world1;\r\nattribute vec4 world2;\r\nattribute vec4 world3;\r\n#else\r\nuniform mat4 world;\r\n#endif\r\n\r\nuniform mat4 viewProjection;\r\n#ifdef BONES\r\nuniform mat4 mBones[BonesPerMesh];\r\n#endif\r\n\r\n#if defined(ALPHATEST) || defined(NEED_UV)\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef INSTANCES\r\nmat4 finalWorld = mat4(world0, world1, world2, world3);\r\n#else\r\nmat4 finalWorld = world;\r\n#endif\r\n\r\n#ifdef BONES\r\nmat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\r\nmat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\r\nmat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\r\nmat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\r\nfinalWorld = finalWorld * (m0 + m1 + m2 + m3);\r\ngl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n#else\r\ngl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n#endif\r\n\r\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\r\n#ifdef UV1\r\nvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\nvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}",
		"depthBoxBlur.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec2 screenSize;\r\n\r\nvoid main(void)\r\n{\r\nvec4 colorDepth = vec4(0.0);\r\n\r\nfor (int x = -OFFSET; x <= OFFSET; x++)\r\nfor (int y = -OFFSET; y <= OFFSET; y++)\r\ncolorDepth += texture2D(textureSampler, vUV + vec2(x, y) / screenSize);\r\n\r\ngl_FragColor = (colorDepth / float((OFFSET * 2 + 1) * (OFFSET * 2 + 1)));\r\n}",
		"depthOfField.fragment" => "\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D highlightsSampler;\r\nuniform sampler2D depthSampler;\r\nuniform sampler2D grainSampler;\r\n\r\nuniform float grain_amount;\r\nuniform float maxZ;\r\nuniform bool blur_noise;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\nuniform float distortion;\r\nuniform float focus_depth;\r\nuniform float aperture;\r\nuniform float edge_blur;\r\nuniform bool highlights;\r\n\r\nvarying vec2 vUV;\r\n\r\n#define PI 3.14159265\r\n\r\nvec2 centered_screen_pos;\r\nfloat radius2;\r\nfloat radius;\r\n\r\n\r\nvec2 getDistortedCoords(vec2 coords) {\r\n\r\nif (distortion == 0.0) { return coords; }\r\n\r\nvec2 direction = 1.0 * normalize(centered_screen_pos);\r\nvec2 dist_coords = vec2(0.5, 0.5);\r\ndist_coords.x = 0.5 + direction.x * radius2 * 1.0;\r\ndist_coords.y = 0.5 + direction.y * radius2 * 1.0;\r\nfloat dist_amount = clamp(distortion*0.23, 0.0, 1.0);\r\n\r\ndist_coords = mix(coords, dist_coords, dist_amount);\r\n\r\nreturn dist_coords;\r\n}\r\n\r\nvec4 getBlurColor(vec2 coords, float size) {\r\n\r\nvec4 col = texture2D(textureSampler, coords);\r\nif (size == 0.0) { return col; }\r\n\r\nfloat blur_level = min(3.0, ceil(size / 1.0));\r\n\r\nfloat w = (size / screen_width);\r\nfloat h = (size / screen_height);\r\nfloat total_weight = 1.0;\r\n\r\ncol += texture2D(textureSampler, coords + vec2(-0.53*w, 0.15*h))*0.93;\r\ncol += texture2D(textureSampler, coords + vec2(0.42*w, -0.69*h))*0.90;\r\ncol += texture2D(textureSampler, coords + vec2(0.20*w, 1.00*h))*0.87;\r\ncol += texture2D(textureSampler, coords + vec2(-0.97*w, -0.72*h))*0.85;\r\ncol += texture2D(textureSampler, coords + vec2(1.37*w, -0.14*h))*0.83;\r\ncol += texture2D(textureSampler, coords + vec2(-1.02*w, 1.16*h))*0.80;\r\ncol += texture2D(textureSampler, coords + vec2(-0.03*w, -1.69*h))*0.78;\r\ncol += texture2D(textureSampler, coords + vec2(1.27*w, 1.34*h))*0.76;\r\ncol += texture2D(textureSampler, coords + vec2(-1.98*w, -0.14*h))*0.74;\r\ncol += texture2D(textureSampler, coords + vec2(1.66*w, -1.32*h))*0.72;\r\ntotal_weight += 8.18;\r\n\r\nif (blur_level > 1.0) {\r\ncol += texture2D(textureSampler, coords + vec2(-0.35*w, 2.22*h))*0.70;\r\ncol += texture2D(textureSampler, coords + vec2(-1.31*w, -1.98*h))*0.67;\r\ncol += texture2D(textureSampler, coords + vec2(2.42*w, 0.61*h))*0.65;\r\ncol += texture2D(textureSampler, coords + vec2(-2.31*w, 1.25*h))*0.63;\r\ncol += texture2D(textureSampler, coords + vec2(0.90*w, -2.59*h))*0.61;\r\ncol += texture2D(textureSampler, coords + vec2(1.14*w, 2.62*h))*0.59;\r\ncol += texture2D(textureSampler, coords + vec2(-2.72*w, -1.21*h))*0.56;\r\ncol += texture2D(textureSampler, coords + vec2(2.93*w, -0.98*h))*0.54;\r\ncol += texture2D(textureSampler, coords + vec2(-1.56*w, 2.80*h))*0.52;\r\ncol += texture2D(textureSampler, coords + vec2(-0.77*w, -3.22*h))*0.49;\r\ntotal_weight += 5.96;\r\n}\r\n\r\nif (blur_level > 2.0) {\r\ncol += texture2D(textureSampler, coords + vec2(2.83*w, 1.92*h))*0.46;\r\ncol += texture2D(textureSampler, coords + vec2(-3.49*w, 0.51*h))*0.44;\r\ncol += texture2D(textureSampler, coords + vec2(2.30*w, -2.82*h))*0.41;\r\ncol += texture2D(textureSampler, coords + vec2(0.22*w, 3.74*h))*0.38;\r\ncol += texture2D(textureSampler, coords + vec2(-2.76*w, -2.68*h))*0.34;\r\ncol += texture2D(textureSampler, coords + vec2(3.95*w, 0.11*h))*0.31;\r\ncol += texture2D(textureSampler, coords + vec2(-3.07*w, 2.65*h))*0.26;\r\ncol += texture2D(textureSampler, coords + vec2(0.48*w, -4.13*h))*0.22;\r\ncol += texture2D(textureSampler, coords + vec2(2.49*w, 3.46*h))*0.15;\r\ntotal_weight += 2.97;\r\n}\r\n\r\ncol /= total_weight; // scales color according to weights\r\ncol.a = 1.0;\r\n\r\n\r\nreturn col;\r\n}\r\n\r\nvec2 rand(vec2 co)\r\n{\r\nfloat noise1 = (fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453));\r\nfloat noise2 = (fract(sin(dot(co, vec2(12.9898, 78.233)*2.0)) * 43758.5453));\r\nreturn clamp(vec2(noise1, noise2), 0.0, 1.0);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\r\ncentered_screen_pos = vec2(vUV.x - 0.5, vUV.y - 0.5);\r\nradius2 = centered_screen_pos.x*centered_screen_pos.x + centered_screen_pos.y*centered_screen_pos.y;\r\nradius = sqrt(radius2);\r\n\r\nvec4 final_color;\r\nvec2 distorted_coords = getDistortedCoords(vUV);\r\nvec2 texels_coords = vec2(vUV.x * screen_width, vUV.y * screen_height); // varies from 0 to SCREEN_WIDTH or _HEIGHT\r\n\r\nfloat dof_blur_amount = 0.0;\r\nfloat depth_bias = 0.0; // positive if the pixel is further than focus depth; negative if closer\r\nif (focus_depth != -1.0) {\r\nvec4 depth_sample = texture2D(depthSampler, distorted_coords);\r\nfloat depth = depth_sample.r;\r\ndepth_bias = depth - focus_depth;\r\n\r\nif (depth_bias > 0.0) { dof_blur_amount = depth_bias * aperture * 2.2; }\r\nelse { dof_blur_amount = depth_bias * depth_bias * aperture * 30.0; }\r\n\r\nif (dof_blur_amount < 0.05) { dof_blur_amount = 0.0; } // no blur at all\r\n}\r\n\r\nfloat edge_blur_amount = 0.0;\r\nif (edge_blur > 0.0) {\r\nedge_blur_amount = clamp((radius*2.0 - 1.0 + 0.15*edge_blur) * 1.5, 0.0, 1.0) * 1.3;\r\n}\r\n\r\nfloat blur_amount = max(edge_blur_amount, dof_blur_amount);\r\n\r\nif (blur_amount == 0.0) {\r\ngl_FragColor = texture2D(textureSampler, distorted_coords);\r\n}\r\nelse {\r\n\r\ngl_FragColor = getBlurColor(distorted_coords, blur_amount * 1.7);\r\n\r\nif (depth_bias > 0.0 && highlights) {\r\ngl_FragColor += clamp(dof_blur_amount, 0.0, 1.0)*texture2D(highlightsSampler, distorted_coords);\r\n}\r\n\r\nif (blur_noise) {\r\nvec2 noise = rand(distorted_coords) * 0.01 * blur_amount;\r\nvec2 blurred_coord = vec2(distorted_coords.x + noise.x, distorted_coords.y + noise.y);\r\ngl_FragColor = 0.04 * texture2D(textureSampler, blurred_coord) + 0.96 * gl_FragColor;\r\n}\r\n}\r\n\r\nif (grain_amount > 0.0) {\r\nvec4 grain_color = texture2D(grainSampler, texels_coords*0.003);\r\ngl_FragColor.rgb += (-0.5 + grain_color.rgb) * 0.20;\r\n}\r\n}",
		"displayPass.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D passSampler;\r\n\r\nvoid main(void)\r\n{\r\ngl_FragColor = texture2D(passSampler, vUV);\r\n}",
		"filter.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform mat4 kernelMatrix;\r\n\r\nvoid main(void)\r\n{\r\nvec3 baseColor = texture2D(textureSampler, vUV).rgb;\r\nvec3 updatedColor = (kernelMatrix * vec4(baseColor, 1.0)).rgb;\r\n\r\ngl_FragColor = vec4(updatedColor, 1.0);\r\n}",
		"fire.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec3 c1;\r\nuniform vec3 c2;\r\nuniform vec3 c3;\r\nuniform vec3 c4;\r\nuniform vec3 c5;\r\nuniform vec3 c6;\r\nuniform vec2 speed;\r\nuniform float shift;\r\nuniform float alphaThreshold;\r\n\r\nvarying vec2 vUV;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nvoid main() {\r\nvec2 p = vUV * 8.0;\r\nfloat q = fbm(p - time * 0.1);\r\nvec2 r = vec2(fbm(p + q + time * speed.x - p.x - p.y), fbm(p + q - time * speed.y));\r\nvec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\r\nvec3 color = c * cos(shift * vUV.y);\r\nfloat luminance = dot(color.rgb, vec3(0.3, 0.59, 0.11));\r\n\r\ngl_FragColor = vec4(color, luminance * alphaThreshold + (1.0 - alphaThreshold));\r\n}",
		"fxaa.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define FXAA_REDUCE_MIN   (1.0/128.0)\r\n#define FXAA_REDUCE_MUL   (1.0/8.0)\r\n#define FXAA_SPAN_MAX     8.0\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform vec2 texelSize;\r\n\r\nvoid main(){\r\nvec2 localTexelSize = texelSize;\r\nvec4 rgbNW = texture2D(textureSampler, (vUV + vec2(-1.0, -1.0) * localTexelSize));\r\nvec4 rgbNE = texture2D(textureSampler, (vUV + vec2(1.0, -1.0) * localTexelSize));\r\nvec4 rgbSW = texture2D(textureSampler, (vUV + vec2(-1.0, 1.0) * localTexelSize));\r\nvec4 rgbSE = texture2D(textureSampler, (vUV + vec2(1.0, 1.0) * localTexelSize));\r\nvec4 rgbM = texture2D(textureSampler, vUV);\r\nvec4 luma = vec4(0.299, 0.587, 0.114, 1.0);\r\nfloat lumaNW = dot(rgbNW, luma);\r\nfloat lumaNE = dot(rgbNE, luma);\r\nfloat lumaSW = dot(rgbSW, luma);\r\nfloat lumaSE = dot(rgbSE, luma);\r\nfloat lumaM = dot(rgbM, luma);\r\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\r\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\r\n\r\nvec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\r\n\r\nfloat dirReduce = max(\r\n(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\r\nFXAA_REDUCE_MIN);\r\n\r\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\r\ndir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\r\nmax(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\r\ndir * rcpDirMin)) * localTexelSize;\r\n\r\nvec4 rgbA = 0.5 * (\r\ntexture2D(textureSampler, vUV + dir * (1.0 / 3.0 - 0.5)) +\r\ntexture2D(textureSampler, vUV + dir * (2.0 / 3.0 - 0.5)));\r\n\r\nvec4 rgbB = rgbA * 0.5 + 0.25 * (\r\ntexture2D(textureSampler, vUV + dir *  -0.5) +\r\ntexture2D(textureSampler, vUV + dir * 0.5));\r\nfloat lumaB = dot(rgbB, luma);\r\nif ((lumaB < lumaMin) || (lumaB > lumaMax)) {\r\ngl_FragColor = rgbA;\r\n}\r\nelse {\r\ngl_FragColor = rgbB;\r\n}\r\n}",
		"grass.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nuniform vec3 herb1Color;\r\nuniform vec3 herb2Color;\r\nuniform vec3 herb3Color;\r\nuniform vec3 groundColor;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nvoid main(void) {\r\nvec3 color = mix(groundColor, herb1Color, rand(gl_FragCoord.xy * 4.0));\r\ncolor = mix(color, herb2Color, rand(gl_FragCoord.xy * 8.0));\r\ncolor = mix(color, herb3Color, rand(gl_FragCoord.xy));\r\ncolor = mix(color, herb1Color, fbm(gl_FragCoord.xy * 16.0));\r\ngl_FragColor = vec4(color, 1.0);\r\n}",
		"layer.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec4 color;\r\n\r\nvoid main(void) {\r\nvec4 baseColor = texture2D(textureSampler, vUV);\r\n\r\ngl_FragColor = baseColor * color;\r\n}",
		"layer.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec2 position;\r\n\r\nuniform mat4 textureMatrix;\r\n\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\r\n\r\nvUV = vec2(textureMatrix * vec4(position * madd + madd, 1.0, 0.0));\r\ngl_Position = vec4(position, 0.0, 1.0);\r\n}",
		"legacydefault.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define MAP_PROJECTION 4.\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vAmbientColor;\r\nuniform vec4 vDiffuseColor;\r\nuniform vec4 vSpecularColor;\r\nuniform vec3 vEmissiveColor;\r\n\r\nvarying vec3 vPositionW;\r\nvarying vec3 vNormalW;\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef LIGHT0\r\nuniform vec4 vLightData0;\r\nuniform vec4 vLightDiffuse0;\r\nuniform vec3 vLightSpecular0;\r\n#ifdef SHADOW0\r\nvarying vec4 vPositionFromLight0;\r\nuniform sampler2D shadowSampler0;\r\n#endif\r\n#ifdef SPOTLIGHT0\r\nuniform vec4 vLightDirection0;\r\n#endif\r\n#ifdef HEMILIGHT0\r\nuniform vec3 vLightGround0;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT1\r\nuniform vec4 vLightData1;\r\nuniform vec4 vLightDiffuse1;\r\nuniform vec3 vLightSpecular1;\r\n#ifdef SHADOW1\r\nvarying vec4 vPositionFromLight1;\r\nuniform sampler2D shadowSampler1;\r\n#endif\r\n#ifdef SPOTLIGHT1\r\nuniform vec4 vLightDirection1;\r\n#endif\r\n#ifdef HEMILIGHT1\r\nuniform vec3 vLightGround1;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT2\r\nuniform vec4 vLightData2;\r\nuniform vec4 vLightDiffuse2;\r\nuniform vec3 vLightSpecular2;\r\n#ifdef SHADOW2\r\nvarying vec4 vPositionFromLight2;\r\nuniform sampler2D shadowSampler2;\r\n#endif\r\n#ifdef SPOTLIGHT2\r\nuniform vec4 vLightDirection2;\r\n#endif\r\n#ifdef HEMILIGHT2\r\nuniform vec3 vLightGround2;\r\n#endif\r\n#endif\r\n\r\n#ifdef LIGHT3\r\nuniform vec4 vLightData3;\r\nuniform vec4 vLightDiffuse3;\r\nuniform vec3 vLightSpecular3;\r\n#ifdef SHADOW3\r\nvarying vec4 vPositionFromLight3;\r\nuniform sampler2D shadowSampler3;\r\n#endif\r\n#ifdef SPOTLIGHT3\r\nuniform vec4 vLightDirection3;\r\n#endif\r\n#ifdef HEMILIGHT3\r\nuniform vec3 vLightGround3;\r\n#endif\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform sampler2D diffuseSampler;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform sampler2D ambientSampler;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvarying vec2 vOpacityUV;\r\nuniform sampler2D opacitySampler;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nvarying vec3 vReflectionUVW;\r\nuniform samplerCube reflectionCubeSampler;\r\nuniform sampler2D reflection2DSampler;\r\nuniform vec3 vReflectionInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform sampler2D specularSampler;\r\n#endif\r\n\r\n#ifdef FRESNEL\r\nfloat computeFresnelTerm(vec3 viewDirection, vec3 worldNormal, float bias, float power)\r\n{\r\nfloat fresnelTerm = pow(bias + abs(dot(viewDirection, worldNormal)), power);\r\nreturn clamp(fresnelTerm, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifdef DIFFUSEFRESNEL\r\nuniform vec4 diffuseLeftColor;\r\nuniform vec4 diffuseRightColor;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\nuniform vec4 opacityParts;\r\n#endif\r\n\r\n#ifdef REFLECTIONFRESNEL\r\nuniform vec4 reflectionLeftColor;\r\nuniform vec4 reflectionRightColor;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nuniform vec4 emissiveLeftColor;\r\nuniform vec4 emissiveRightColor;\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n\r\nfloat unpack(vec4 color)\r\n{\r\nconst vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\r\nreturn dot(color, bitShift);\r\n}\r\n\r\nfloat unpackHalf(vec2 color)\r\n{\r\nreturn color.x + (color.y / 255.0);\r\n}\r\n\r\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler)\r\n{\r\nvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\nvec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\r\n\r\nif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nfloat shadow = unpack(texture2D(shadowSampler, uv));\r\n\r\nif (depth.z > shadow)\r\n{\r\nreturn 0.;\r\n}\r\nreturn 1.;\r\n}\r\n\r\nfloat ChebychevInequality(vec2 moments, float t)\r\n{\r\nif (t <= moments.x)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nfloat variance = moments.y - (moments.x * moments.x);\r\nvariance = max(variance, 0.);\r\n\r\nfloat d = t - moments.x;\r\nreturn variance / (variance + d * d);\r\n}\r\n\r\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\r\n{\r\nvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\nvec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\r\n\r\nif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n{\r\nreturn 1.0;\r\n}\r\n\r\nvec4 texel = texture2D(shadowSampler, uv);\r\n\r\nvec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\r\nreturn clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\r\n}\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n#ifdef FOG\r\n\r\n#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform vec4 vFogInfos;\r\nuniform vec3 vFogColor;\r\nvarying float fFogDistance;\r\n\r\nfloat CalcFogFactor()\r\n{\r\nfloat fogCoeff = 1.0;\r\nfloat fogStart = vFogInfos.y;\r\nfloat fogEnd = vFogInfos.z;\r\nfloat fogDensity = vFogInfos.w;\r\n\r\nif (FOGMODE_LINEAR == vFogInfos.x)\r\n{\r\nfogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\r\n}\r\nelse if (FOGMODE_EXP == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\r\n}\r\nelse if (FOGMODE_EXP2 == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\r\n}\r\n\r\nreturn clamp(fogCoeff, 0.0, 1.0);\r\n}\r\n#endif\r\n\r\nmat3 computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor) {\r\nmat3 result;\r\n\r\nvec3 lightVectorW;\r\nif (lightData.w == 0.)\r\n{\r\nlightVectorW = normalize(lightData.xyz - vPositionW);\r\n}\r\nelse\r\n{\r\nlightVectorW = normalize(-lightData.xyz);\r\n}\r\n\r\nfloat ndl = max(0., dot(vNormal, lightVectorW));\r\n\r\nvec3 angleW = normalize(viewDirectionW + lightVectorW);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = max(0., pow(specComp, max(1.0, vSpecularColor.a)));\r\n\r\nresult[0] = ndl * diffuseColor.rgb;\r\nresult[1] = specComp * specularColor;\r\nresult[2] = vec3(0.);\r\n\r\nreturn result;\r\n}\r\n\r\nmat3 computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec4 diffuseColor, vec3 specularColor) {\r\nmat3 result;\r\n\r\nvec3 lightVectorW = normalize(lightData.xyz - vPositionW);\r\n\r\nfloat cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\r\nfloat spotAtten = 0.0;\r\n\r\nif (cosAngle >= lightDirection.w)\r\n{\r\ncosAngle = max(0., pow(cosAngle, lightData.w));\r\nspotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\r\n\r\nfloat ndl = max(0., dot(vNormal, -lightDirection.xyz));\r\n\r\nvec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = pow(specComp, vSpecularColor.a);\r\n\r\nresult[0] = ndl * spotAtten * diffuseColor.rgb;\r\nresult[1] = specComp * specularColor * spotAtten;\r\nresult[2] = vec3(0.);\r\n\r\nreturn result;\r\n}\r\n\r\nresult[0] = vec3(0.);\r\nresult[1] = vec3(0.);\r\nresult[2] = vec3(0.);\r\n\r\nreturn result;\r\n}\r\n\r\nmat3 computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor, vec3 groundColor) {\r\nmat3 result;\r\n\r\nfloat ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\r\n\r\nvec3 angleW = normalize(viewDirectionW + lightData.xyz);\r\nfloat specComp = max(0., dot(vNormal, angleW));\r\nspecComp = pow(specComp, vSpecularColor.a);\r\n\r\nresult[0] = mix(groundColor, diffuseColor.rgb, ndl);\r\nresult[1] = specComp * specularColor;\r\nresult[2] = vec3(0.);\r\n\r\nreturn result;\r\n}\r\n\r\nvoid main(void) {\r\n#ifdef CLIPPLANE\r\nif (fClipDistance > 0.0)\r\ndiscard;\r\n#endif\r\n\r\nvec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\nvec4 baseColor = vec4(1., 1., 1., 1.);\r\nvec3 diffuseColor = vDiffuseColor.rgb;\r\n\r\n#ifdef VERTEXCOLOR\r\nbaseColor.rgb *= vColor.rgb;\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nbaseColor = texture2D(diffuseSampler, vDiffuseUV);\r\n\r\n#ifdef ALPHATEST\r\nif (baseColor.a < 0.4)\r\ndiscard;\r\n#endif\r\n\r\nbaseColor.rgb *= vDiffuseInfos.y;\r\n#endif\r\n\r\nvec3 normalW = normalize(vNormalW);\r\n\r\nvec3 baseAmbientColor = vec3(1., 1., 1.);\r\n\r\n#ifdef AMBIENT\r\nbaseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\r\n#endif\r\n\r\nvec3 diffuseBase = vec3(0., 0., 0.);\r\nvec3 specularBase = vec3(0., 0., 0.);\r\nfloat shadow = 1.;\r\n\r\n#ifdef LIGHT0\r\n#ifdef SPOTLIGHT0\r\nmat3 info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0, vLightSpecular0);\r\n#endif\r\n#ifdef HEMILIGHT0\r\nmat3 info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0, vLightGround0);\r\n#endif\r\n#ifdef POINTDIRLIGHT0\r\nmat3 info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0);\r\n#endif\r\n#ifdef SHADOW0\r\n#ifdef SHADOWVSM0\r\nshadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\r\n#else\r\nshadow = computeShadow(vPositionFromLight0, shadowSampler0);\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info[0] * shadow;\r\nspecularBase += info[1] * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT1\r\n#ifdef SPOTLIGHT1\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1, vLightSpecular1);\r\n#endif\r\n#ifdef HEMILIGHT1\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1, vLightGround1);\r\n#endif\r\n#ifdef POINTDIRLIGHT1\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1);\r\n#endif\r\n#ifdef SHADOW1\r\n#ifdef SHADOWVSM1\r\nshadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\r\n#else\r\nshadow = computeShadow(vPositionFromLight1, shadowSampler1);\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info[0] * shadow;\r\nspecularBase += info[1] * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT2\r\n#ifdef SPOTLIGHT2\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2, vLightSpecular2);\r\n#endif\r\n#ifdef HEMILIGHT2\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2, vLightGround2);\r\n#endif\r\n#ifdef POINTDIRLIGHT2\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2);\r\n#endif\r\n#ifdef SHADOW2\r\n#ifdef SHADOWVSM2\r\nshadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\r\n#else\r\nshadow = computeShadow(vPositionFromLight2, shadowSampler2);\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info[0] * shadow;\r\nspecularBase += info[1] * shadow;\r\n#endif\r\n\r\n#ifdef LIGHT3\r\n#ifdef SPOTLIGHT3\r\ninfo = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3, vLightSpecular3);\r\n#endif\r\n#ifdef HEMILIGHT3\r\ninfo = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3, vLightGround3);\r\n#endif\r\n#ifdef POINTDIRLIGHT3\r\ninfo = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3);\r\n#endif\r\n#ifdef SHADOW3\r\n#ifdef SHADOWVSM3\r\nshadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\r\n#else\r\nshadow = computeShadow(vPositionFromLight3, shadowSampler3);\r\n#endif\r\n#else\r\nshadow = 1.;\r\n#endif\r\ndiffuseBase += info[0] * shadow;\r\nspecularBase += info[1] * shadow;\r\n#endif\r\n\r\nvec3 reflectionColor = vec3(0., 0., 0.);\r\n\r\n#ifdef REFLECTION\r\nif (vReflectionInfos.z != 0.0)\r\n{\r\nreflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y;\r\n}\r\nelse\r\n{\r\nvec2 coords = vReflectionUVW.xy;\r\n\r\nif (vReflectionInfos.x == MAP_PROJECTION)\r\n{\r\ncoords /= vReflectionUVW.z;\r\n}\r\n\r\ncoords.y = 1.0 - coords.y;\r\n\r\nreflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y;\r\n}\r\n\r\n#ifdef REFLECTIONFRESNEL\r\nfloat reflectionFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, reflectionRightColor.a, reflectionLeftColor.a);\r\n\r\nreflectionColor *= reflectionLeftColor.rgb * (1.0 - reflectionFresnelTerm) + reflectionFresnelTerm * reflectionRightColor.rgb;\r\n#endif\r\n#endif\r\n\r\nfloat alpha = vDiffuseColor.a;\r\n\r\n#ifdef OPACITY\r\nvec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\r\n#ifdef OPACITYRGB\r\nopacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\r\nalpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\r\n#else\r\nalpha *= opacityMap.a * vOpacityInfos.y;\r\n#endif\r\n#endif\r\n\r\n#ifdef VERTEXALPHA\r\nalpha *= vColor.a;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\nfloat opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\r\n\r\nalpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\r\n#endif\r\n\r\nvec3 emissiveColor = vEmissiveColor;\r\n#ifdef EMISSIVE\r\nemissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nfloat emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\r\n\r\nemissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\r\n#endif\r\n\r\nvec3 specularColor = vSpecularColor.rgb;\r\n#ifdef SPECULAR\r\nspecularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\r\n#endif\r\n\r\n#ifdef DIFFUSEFRESNEL\r\nfloat diffuseFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, diffuseRightColor.a, diffuseLeftColor.a);\r\n\r\ndiffuseBase *= diffuseLeftColor.rgb * (1.0 - diffuseFresnelTerm) + diffuseFresnelTerm * diffuseRightColor.rgb;\r\n#endif\r\n\r\nvec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\r\nvec3 finalSpecular = specularBase * specularColor;\r\n\r\nvec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\r\n\r\n#ifdef FOG\r\nfloat fog = CalcFogFactor();\r\ncolor.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\r\n#endif\r\n\r\ngl_FragColor = color;\r\n}",
		"legacydefault.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define MAP_EXPLICIT 0.\r\n#define MAP_SPHERICAL 1.\r\n#define MAP_PLANAR 2.\r\n#define MAP_CUBIC 3.\r\n#define MAP_PROJECTION 4.\r\n#define MAP_SKYBOX 5.\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#ifdef VERTEXCOLOR\r\nattribute vec4 color;\r\n#endif\r\n#ifdef BONES\r\nattribute vec4 matricesIndices;\r\nattribute vec4 matricesWeights;\r\n#endif\r\n\r\nuniform mat4 world;\r\nuniform mat4 view;\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform mat4 ambientMatrix;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvarying vec2 vOpacityUV;\r\nuniform mat4 opacityMatrix;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nuniform vec3 vEyePosition;\r\nvarying vec3 vReflectionUVW;\r\nuniform vec3 vReflectionInfos;\r\nuniform mat4 reflectionMatrix;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform mat4 specularMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nvarying vec2 vBumpUV;\r\nuniform vec2 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#ifdef BONES\r\nuniform mat4 mBones[BonesPerMesh];\r\n#endif\r\n\r\nvarying vec3 vPositionW;\r\nvarying vec3 vNormalW;\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nuniform vec4 vClipPlane;\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n#ifdef FOG\r\nvarying float fFogDistance;\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n#ifdef LIGHT0\r\nuniform mat4 lightMatrix0;\r\nvarying vec4 vPositionFromLight0;\r\n#endif\r\n#ifdef LIGHT1\r\nuniform mat4 lightMatrix1;\r\nvarying vec4 vPositionFromLight1;\r\n#endif\r\n#ifdef LIGHT2\r\nuniform mat4 lightMatrix2;\r\nvarying vec4 vPositionFromLight2;\r\n#endif\r\n#ifdef LIGHT3\r\nuniform mat4 lightMatrix3;\r\nvarying vec4 vPositionFromLight3;\r\n#endif\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\r\n{\r\nif (mode == MAP_SPHERICAL)\r\n{\r\nvec3 coords = vec3(view * vec4(worldNormal, 0.0));\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 1.0));\r\n}\r\nelse if (mode == MAP_PLANAR)\r\n{\r\nvec3 viewDir = worldPos.xyz - vEyePosition;\r\nvec3 coords = normalize(reflect(viewDir, worldNormal));\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 1));\r\n}\r\nelse if (mode == MAP_CUBIC)\r\n{\r\nvec3 viewDir = worldPos.xyz - vEyePosition;\r\nvec3 coords = reflect(viewDir, worldNormal);\r\n\r\nreturn vec3(reflectionMatrix * vec4(coords, 0));\r\n}\r\nelse if (mode == MAP_PROJECTION)\r\n{\r\nreturn vec3(reflectionMatrix * (view * worldPos));\r\n}\r\nelse if (mode == MAP_SKYBOX)\r\n{\r\nreturn position;\r\n}\r\n\r\nreturn vec3(0, 0, 0);\r\n}\r\n#endif\r\n\r\nvoid main(void) {\r\nmat4 finalWorld;\r\n\r\n#ifdef BONES\r\nmat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\r\nmat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\r\nmat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\r\n\r\n#ifdef BONES4\r\nmat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\r\nfinalWorld = world * (m0 + m1 + m2 + m3);\r\n#else\r\nfinalWorld = world * (m0 + m1 + m2);\r\n#endif\r\n\r\n#else\r\nfinalWorld = world;\r\n#endif\r\n\r\ngl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n\r\nvec4 worldPos = finalWorld * vec4(position, 1.0);\r\nvPositionW = vec3(worldPos);\r\nvNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\r\n\r\n#ifndef UV1\r\nvec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\nvec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\nif (vDiffuseInfos.x == 0.)\r\n{\r\nvDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nif (vAmbientInfos.x == 0.)\r\n{\r\nvAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef OPACITY\r\nif (vOpacityInfos.x == 0.)\r\n{\r\nvOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef REFLECTION\r\nvReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), vNormalW);\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nif (vEmissiveInfos.x == 0.)\r\n{\r\nvEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef SPECULAR\r\nif (vSpecularInfos.x == 0.)\r\n{\r\nvSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef BUMP\r\nif (vBumpInfos.x == 0.)\r\n{\r\nvBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n}\r\nelse\r\n{\r\nvBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n}\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nfClipDistance = dot(worldPos, vClipPlane);\r\n#endif\r\n\r\n#ifdef FOG\r\nfFogDistance = (view * worldPos).z;\r\n#endif\r\n\r\n#ifdef SHADOWS\r\n#ifdef LIGHT0\r\nvPositionFromLight0 = lightMatrix0 * worldPos;\r\n#endif\r\n#ifdef LIGHT1\r\nvPositionFromLight1 = lightMatrix1 * worldPos;\r\n#endif\r\n#ifdef LIGHT2\r\nvPositionFromLight2 = lightMatrix2 * worldPos;\r\n#endif\r\n#ifdef LIGHT3\r\nvPositionFromLight3 = lightMatrix3 * worldPos;\r\n#endif\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvColor = color;\r\n#endif\r\n}",
		"lensFlare.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec4 color;\r\n\r\nvoid main(void) {\r\nvec4 baseColor = texture2D(textureSampler, vUV);\r\n\r\ngl_FragColor = baseColor * color;\r\n}",
		"lensFlare.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec2 position;\r\n\r\nuniform mat4 viewportMatrix;\r\n\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\r\n\r\nvUV = position * madd + madd;\r\ngl_Position = viewportMatrix * vec4(position, 0.0, 1.0);\r\n}",
		"lensHighlights.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform sampler2D textureSampler; // original color\r\n\r\nuniform float gain;\r\nuniform float threshold;\r\nuniform bool pentagon;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\n\r\nvarying vec2 vUV;\r\n\r\nvec4 highlightColor(vec4 color) {\r\nvec4 highlight = color;\r\nfloat luminance = dot(highlight.rgb, vec3(0.2125, 0.7154, 0.0721));\r\nfloat lum_threshold;\r\nif (threshold > 1.0) { lum_threshold = 0.94 + 0.01 * threshold; }\r\nelse { lum_threshold = 0.5 + 0.44 * threshold; }\r\n\r\nluminance = clamp((luminance - lum_threshold) * (1.0 / (1.0 - lum_threshold)), 0.0, 1.0);\r\n\r\nhighlight *= luminance * gain;\r\nhighlight.a = 1.0;\r\n\r\nreturn highlight;\r\n}\r\n\r\nvoid main(void)\r\n{\r\nvec4 original = texture2D(textureSampler, vUV);\r\n\r\nif (gain == -1.0) {\r\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\nreturn;\r\n}\r\n\r\nfloat w = 2.0 / screen_width;\r\nfloat h = 2.0 / screen_height;\r\n\r\nfloat weight = 1.0;\r\n\r\nvec4 blurred = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\nif (pentagon) {\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.84*w, 0.43*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.48*w, -1.29*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.61*w, 1.51*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.55*w, -0.74*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.71*w, -0.52*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.94*w, 1.59*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.40*w, -1.87*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.62*w, 1.16*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.09*w, 0.25*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.46*w, -1.71*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.08*w, 2.42*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.85*w, -1.89*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.89*w, 0.16*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.29*w, 1.88*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.40*w, -2.81*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.54*w, 2.26*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.60*w, -0.61*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.31*w, -1.30*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.83*w, 2.53*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.12*w, -2.48*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.60*w, 1.11*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.82*w, 0.99*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.50*w, -2.81*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.85*w, 3.33*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.94*w, -1.92*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.27*w, -0.53*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.95*w, 2.48*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.23*w, -3.04*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.17*w, 2.05*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.97*w, -0.04*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.25*w, -2.00*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.31*w, 3.08*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.94*w, -2.59*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.37*w, 0.64*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.13*w, 1.93*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.03*w, -3.65*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.60*w, 3.17*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.14*w, -1.19*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.00*w, -1.19*h)));\r\n}\r\nelse {\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.85*w, 0.36*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.52*w, -1.14*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.46*w, 1.42*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.46*w, -0.83*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.79*w, -0.42*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.11*w, 1.62*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.29*w, -2.07*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.69*w, 1.39*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.28*w, 0.12*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.65*w, -1.69*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.08*w, 2.44*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.63*w, -1.90*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.55*w, 0.31*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.13*w, 1.52*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.56*w, -2.61*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.38*w, 2.34*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.64*w, -0.81*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.53*w, -1.21*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.06*w, 2.63*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.00*w, -2.69*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.59*w, 1.32*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.82*w, 0.78*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.57*w, -2.50*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.54*w, 2.93*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.39*w, -1.81*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.01*w, -0.28*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.04*w, 2.25*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.02*w, -3.05*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.09*w, 2.25*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.07*w, -0.25*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.44*w, -1.90*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.52*w, 3.05*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.68*w, -2.61*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.01*w, 0.79*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.76*w, 1.46*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.05*w, -2.94*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.21*w, 2.88*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.84*w, -1.30*h)));\r\nblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.98*w, -0.96*h)));\r\n}\r\n\r\nblurred /= 39.0;\r\n\r\ngl_FragColor = blurred;\r\n\r\n}",
		"marble.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nuniform float numberOfTilesHeight;\r\nuniform float numberOfTilesWidth;\r\nuniform float amplitude;\r\nuniform vec3 brickColor;\r\nuniform vec3 jointColor;\r\n\r\nconst vec3 tileSize = vec3(1.1, 1.0, 1.1);\r\nconst vec3 tilePct = vec3(0.98, 1.0, 0.98);\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat turbulence(vec2 P)\r\n{\r\nfloat val = 0.0;\r\nfloat freq = 1.0;\r\nfor (int i = 0; i < 4; i++)\r\n{\r\nval += abs(noise(P*freq) / freq);\r\nfreq *= 2.07;\r\n}\r\nreturn val;\r\n}\r\n\r\nfloat round(float number){\r\nreturn sign(number)*floor(abs(number) + 0.5);\r\n}\r\n\r\nvec3 marble_color(float x)\r\n{\r\nvec3 col;\r\nx = 0.5*(x + 1.);\r\nx = sqrt(x);\r\nx = sqrt(x);\r\nx = sqrt(x);\r\ncol = vec3(.2 + .75*x);\r\ncol.b *= 0.95;\r\nreturn col;\r\n}\r\n\r\nvoid main()\r\n{\r\nfloat brickW = 1.0 / numberOfTilesWidth;\r\nfloat brickH = 1.0 / numberOfTilesHeight;\r\nfloat jointWPercentage = 0.01;\r\nfloat jointHPercentage = 0.01;\r\nvec3 color = brickColor;\r\nfloat yi = vUV.y / brickH;\r\nfloat nyi = round(yi);\r\nfloat xi = vUV.x / brickW;\r\n\r\nif (mod(floor(yi), 2.0) == 0.0){\r\nxi = xi - 0.5;\r\n}\r\n\r\nfloat nxi = round(xi);\r\nvec2 brickvUV = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) / brickW);\r\n\r\nif (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\r\ncolor = mix(jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\r\n}\r\nelse if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\r\ncolor = mix(jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\r\n}\r\nelse {\r\nfloat t = 6.28 * brickvUV.x / (tileSize.x + noise(vec2(vUV)*6.0));\r\nt += amplitude * turbulence(brickvUV.xy);\r\nt = sin(t);\r\ncolor = marble_color(t);\r\n}\r\n\r\ngl_FragColor = vec4(color, 0.0);\r\n}",
		"oculusDistortionCorrection.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform vec2 LensCenter;\r\nuniform vec2 Scale;\r\nuniform vec2 ScaleIn;\r\nuniform vec4 HmdWarpParam;\r\n\r\nvec2 HmdWarp(vec2 in01) {\r\n\r\nvec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\r\nfloat rSq = theta.x * theta.x + theta.y * theta.y;\r\nvec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\r\nreturn LensCenter + Scale * rvector;\r\n}\r\n\r\nvoid main(void)\r\n{\r\nvec2 tc = HmdWarp(vUV);\r\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\r\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\nelse{\r\ngl_FragColor = vec4(texture2D(textureSampler, tc).rgb, 1.0);\r\n}\r\n}",
		"outline.fragment" => "precision highp float;\r\n\r\nuniform vec4 color;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nvoid main(void) {\r\n#ifdef ALPHATEST\r\nif (texture2D(diffuseSampler, vUV).a < 0.4)\r\ndiscard;\r\n#endif\r\n\r\ngl_FragColor = color;\r\n}",
		"outline.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n\r\n#ifdef BONES\r\nattribute vec4 matricesIndices;\r\nattribute vec4 matricesWeights;\r\n#endif\r\n\r\nuniform float offset;\r\n\r\n#ifdef INSTANCES\r\nattribute vec4 world0;\r\nattribute vec4 world1;\r\nattribute vec4 world2;\r\nattribute vec4 world3;\r\n#else\r\nuniform mat4 world;\r\n#endif\r\n\r\nuniform mat4 viewProjection;\r\n#ifdef BONES\r\nuniform mat4 mBones[BonesPerMesh];\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef INSTANCES\r\nmat4 finalWorld = mat4(world0, world1, world2, world3);\r\n#else\r\nmat4 finalWorld = world;\r\n#endif\r\n\r\nvec3 offsetPosition = position + normal * offset;\r\n\r\n#ifdef BONES\r\nmat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\r\nmat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\r\nmat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\r\nmat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\r\nfinalWorld = finalWorld * (m0 + m1 + m2 + m3);\r\ngl_Position = viewProjection * finalWorld * vec4(offsetPosition, 1.0);\r\n#else\r\ngl_Position = viewProjection * finalWorld * vec4(offsetPosition, 1.0);\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n#ifdef UV1\r\nvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\nvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}",
		"particles.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nuniform vec4 textureMask;\r\nuniform sampler2D diffuseSampler;\r\n\r\n#ifdef CLIPPLANE\r\nvarying float fClipDistance;\r\n#endif\r\n\r\nvoid main(void) {\r\n#ifdef CLIPPLANE\r\nif (fClipDistance > 0.0)\r\ndiscard;\r\n#endif\r\nvec4 baseColor = texture2D(diffuseSampler, vUV);\r\n\r\ngl_FragColor = (baseColor * textureMask + (vec4(1., 1., 1., 1.) - textureMask)) * vColor;\r\n}",
		"particles.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\nattribute vec4 color;\r\nattribute vec4 options;\r\n\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\n\r\n#ifdef CLIPPLANE\r\nuniform vec4 vClipPlane;\r\nuniform mat4 invView;\r\nvarying float fClipDistance;\r\n#endif\r\n\r\nvoid main(void) {\r\nvec3 viewPos = (view * vec4(position, 1.0)).xyz;\r\nvec3 cornerPos;\r\nfloat size = options.y;\r\nfloat angle = options.x;\r\nvec2 offset = options.zw;\r\n\r\ncornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\r\n\r\nvec3 rotatedCorner;\r\nrotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\r\nrotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\r\nrotatedCorner.z = 0.;\r\n\r\nviewPos += rotatedCorner;\r\ngl_Position = projection * vec4(viewPos, 1.0);\r\n\r\nvColor = color;\r\nvUV = offset;\r\n\r\n#ifdef CLIPPLANE\r\nvec4 worldPos = invView * vec4(viewPos, 1.0);\r\nfClipDistance = dot(worldPos, vClipPlane);\r\n#endif\r\n}",
		"pass.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nvoid main(void)\r\n{\r\ngl_FragColor = texture2D(textureSampler, vUV);\r\n}",
		"postprocess.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec2 position;\r\n\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\r\n\r\nvUV = position * madd + madd;\r\ngl_Position = vec4(position, 0.0, 1.0);\r\n}",
		"procedural.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec2 position;\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\r\nvPosition = position;\r\nvUV = position * madd + madd;\r\ngl_Position = vec4(position, 0.0, 1.0);\r\n}",
		"refraction.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D refractionSampler;\r\n\r\nuniform vec3 baseColor;\r\nuniform float depth;\r\nuniform float colorLevel;\r\n\r\nvoid main() {\r\nfloat ref = 1.0 - texture2D(refractionSampler, vUV).r;\r\n\r\nvec2 uv = vUV - vec2(0.5);\r\nvec2 offset = uv * depth * ref;\r\nvec3 sourceColor = texture2D(textureSampler, vUV - offset).rgb;\r\n\r\ngl_FragColor = vec4(sourceColor + sourceColor * ref * colorLevel, 1.0);\r\n}",
		"road.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vUV;\r\nuniform vec3 roadColor;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nvoid main(void) {\r\nfloat ratioy = mod(gl_FragCoord.y * 100.0 , fbm(vUV * 2.0));\r\nvec3 color = roadColor * ratioy;\r\ngl_FragColor = vec4(color, 1.0);\r\n}",
		"shadowMap.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvec4 pack(float depth)\r\n{\r\nconst vec4 bit_shift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\r\nconst vec4 bit_mask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\r\n\r\nvec4 res = fract(depth * bit_shift);\r\nres -= res.xxyz * bit_mask;\r\n\r\nreturn res;\r\n}\r\n\r\nvec2 packHalf(float depth)\r\n{\r\nconst vec2 bitOffset = vec2(1.0 / 255., 0.);\r\nvec2 color = vec2(depth, fract(depth * 255.));\r\n\r\nreturn color - (color.yy * bitOffset);\r\n}\r\n\r\nvarying vec4 vPosition;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ALPHATEST\r\nif (texture2D(diffuseSampler, vUV).a < 0.4)\r\ndiscard;\r\n#endif\r\nfloat depth = vPosition.z / vPosition.w;\r\ndepth = depth * 0.5 + 0.5;\r\n\r\n#ifdef VSM\r\nfloat moment1 = depth;\r\nfloat moment2 = moment1 * moment1;\r\n\r\ngl_FragColor = vec4(packHalf(moment1), packHalf(moment2));\r\n#else\r\ngl_FragColor = pack(depth);\r\n#endif\r\n}",
		"shadowMap.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\n#ifdef BONES\r\nattribute vec4 matricesIndices;\r\nattribute vec4 matricesWeights;\r\n#endif\r\n\r\n#ifdef INSTANCES\r\nattribute vec4 world0;\r\nattribute vec4 world1;\r\nattribute vec4 world2;\r\nattribute vec4 world3;\r\n#else\r\nuniform mat4 world;\r\n#endif\r\n\r\nuniform mat4 viewProjection;\r\n#ifdef BONES\r\nuniform mat4 mBones[BonesPerMesh];\r\n#endif\r\n\r\nvarying vec4 vPosition;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef INSTANCES\r\nmat4 finalWorld = mat4(world0, world1, world2, world3);\r\n#else\r\nmat4 finalWorld = world;\r\n#endif\r\n\r\n#ifdef BONES\r\nmat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\r\nmat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\r\nmat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\r\nmat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\r\nfinalWorld = finalWorld * (m0 + m1 + m2 + m3);\r\n#endif\r\n\r\nvPosition = viewProjection * finalWorld * vec4(position, 1.0);\r\ngl_Position = vPosition;\r\n\r\n#ifdef ALPHATEST\r\n#ifdef UV1\r\nvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\nvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}",
		"sprites.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform bool alphaTest;\r\n\r\nvarying vec4 vColor;\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n\r\n#ifdef FOG\r\n\r\n#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform vec4 vFogInfos;\r\nuniform vec3 vFogColor;\r\nvarying float fFogDistance;\r\n\r\nfloat CalcFogFactor()\r\n{\r\nfloat fogCoeff = 1.0;\r\nfloat fogStart = vFogInfos.y;\r\nfloat fogEnd = vFogInfos.z;\r\nfloat fogDensity = vFogInfos.w;\r\n\r\nif (FOGMODE_LINEAR == vFogInfos.x)\r\n{\r\nfogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\r\n}\r\nelse if (FOGMODE_EXP == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\r\n}\r\nelse if (FOGMODE_EXP2 == vFogInfos.x)\r\n{\r\nfogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\r\n}\r\n\r\nreturn min(1., max(0., fogCoeff));\r\n}\r\n#endif\r\n\r\n\r\nvoid main(void) {\r\nvec4 baseColor = texture2D(diffuseSampler, vUV);\r\n\r\nif (alphaTest)\r\n{\r\nif (baseColor.a < 0.95)\r\ndiscard;\r\n}\r\n\r\nbaseColor *= vColor;\r\n\r\n#ifdef FOG\r\nfloat fog = CalcFogFactor();\r\nbaseColor.rgb = fog * baseColor.rgb + (1.0 - fog) * vFogColor;\r\n#endif\r\n\r\ngl_FragColor = baseColor;\r\n}",
		"sprites.vertex" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nattribute vec4 position;\r\nattribute vec4 options;\r\nattribute vec4 cellInfo;\r\nattribute vec4 color;\r\n\r\nuniform vec2 textureInfos;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\n\r\n#ifdef FOG\r\nvarying float fFogDistance;\r\n#endif\r\n\r\nvoid main(void) {\r\nvec3 viewPos = (view * vec4(position.xyz, 1.0)).xyz;\r\nvec2 cornerPos;\r\n\r\nfloat angle = position.w;\r\nvec2 size = vec2(options.x, options.y);\r\nvec2 offset = options.zw;\r\nvec2 uvScale = textureInfos.xy;\r\n\r\ncornerPos = vec2(offset.x - 0.5, offset.y  - 0.5) * size;\r\n\r\nvec3 rotatedCorner;\r\nrotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\r\nrotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\r\nrotatedCorner.z = 0.;\r\n\r\nviewPos += rotatedCorner;\r\ngl_Position = projection * vec4(viewPos, 1.0);\r\n\r\nvColor = color;\r\n\r\nvec2 uvOffset = vec2(abs(offset.x - cellInfo.x), 1.0 - abs(offset.y - cellInfo.y));\r\n\r\nvUV = (uvOffset + cellInfo.zw) * uvScale;\r\n\r\n#ifdef FOG\r\nfFogDistance = viewPos.z;\r\n#endif\r\n}",
		"ssao.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define SAMPLES 16\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D randomSampler;\r\n\r\nuniform float randTextureTiles;\r\nuniform float samplesFactor;\r\nuniform vec3 sampleSphere[16];\r\n\r\nuniform float totalStrength;\r\nuniform float radius;\r\nuniform float area;\r\nuniform float fallOff;\r\n\r\nvarying vec2 vUV;\r\n\r\nconst vec2 offset1 = vec2(0.0, 0.001);\r\nconst vec2 offset2 = vec2(0.001, 0.0);\r\n\r\nvec3 normalFromDepth(const float depth, const vec2 coords) {\r\nfloat depth1 = texture2D(textureSampler, coords + offset1).r;\r\nfloat depth2 = texture2D(textureSampler, coords + offset2).r;\r\n\r\nvec3 p1 = vec3(offset1, depth1 - depth);\r\nvec3 p2 = vec3(offset2, depth2 - depth);\r\n\r\nvec3 normal = cross(p1, p2);\r\nnormal.z = -normal.z;\r\n\r\nreturn normalize(normal);\r\n}\r\n\r\nvoid main(void)\r\n{\r\nconst float base = 0.2;\r\n\r\nvec3 random = texture2D(randomSampler, vUV * randTextureTiles).rgb;\r\nfloat depth = texture2D(textureSampler, vUV).r;\r\nvec3 position = vec3(vUV, depth);\r\nvec3 normal = normalFromDepth(depth, vUV);\r\nfloat radiusDepth = radius / depth;\r\nfloat occlusion = 0.0;\r\n\r\nvec3 ray;\r\nvec3 hemiRay;\r\nfloat occlusionDepth;\r\nfloat difference;\r\n\r\nfor (int i = 0; i < SAMPLES; i++)\r\n{\r\nray = radiusDepth * reflect(sampleSphere[i], random);\r\nhemiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\nocclusionDepth = texture2D(textureSampler, clamp(hemiRay.xy, 0.0, 1.0)).r;\r\ndifference = depth - occlusionDepth;\r\n\r\nocclusion += step(fallOff, difference) * (1.0 - smoothstep(fallOff, area, difference));\r\n}\r\n\r\nfloat ao = 1.0 - totalStrength * occlusion * samplesFactor;\r\n\r\nfloat result = clamp(ao + base, 0.0, 1.0);\r\ngl_FragColor.r = result;\r\ngl_FragColor.g = result;\r\ngl_FragColor.b = result;\r\ngl_FragColor.a = 1.0;\r\n}",
		"ssaoCombine.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D originalColor;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\ngl_FragColor = texture2D(originalColor, vUV) * texture2D(textureSampler, vUV);\r\n}",
		"volumetricLightScattering.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D lightScatteringSampler;\r\n\r\nuniform float decay;\r\nuniform float exposure;\r\nuniform float weight;\r\nuniform float density;\r\nuniform vec2 meshPositionOnScreen;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\nvec2 tc = vUV;\r\nvec2 deltaTexCoord = (tc - meshPositionOnScreen.xy);\r\ndeltaTexCoord *= 1.0 / float(NUM_SAMPLES) * density;\r\n\r\nfloat illuminationDecay = 1.0;\r\n\r\nvec4 color = texture2D(lightScatteringSampler, tc) * 0.4;\r\n\r\nfor(int i=0; i < NUM_SAMPLES; i++) {\r\ntc -= deltaTexCoord;\r\nvec4 sample = texture2D(lightScatteringSampler, tc) * 0.4;\r\nsample *= illuminationDecay * weight;\r\ncolor += sample;\r\nilluminationDecay *= decay;\r\n}\r\n\r\nvec4 realColor = texture2D(textureSampler, vUV);\r\ngl_FragColor = ((vec4((vec3(color.r, color.g, color.b) * exposure), 1)) + (realColor * (1.5 - 0.4)));\r\n}",
		"volumetricLightScatteringPass.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#if defined(ALPHATEST) || defined(BASIC_RENDER) || defined(OPACITY)\r\nvarying vec2 vUV;\r\n#endif\r\n\r\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#if defined(OPACITY)\r\nuniform sampler2D opacitySampler;\r\nuniform float opacityLevel;\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\r\nvec4 diffuseColor = texture2D(diffuseSampler, vUV);\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\nif (diffuseColor.a < 0.4)\r\ndiscard;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvec4 opacityColor = texture2D(opacitySampler, vUV);\r\nfloat alpha = 1.0;\r\n\r\n#ifdef OPACITYRGB\r\nopacityColor.rgb = opacityColor.rgb * vec3(0.3, 0.59, 0.11);\r\nalpha *= (opacityColor.x + opacityColor.y + opacityColor.z) * opacityLevel;\r\n#else\r\nalpha *= opacityColor.a * opacityLevel;\r\n#endif\r\n\r\n#if defined(BASIC_RENDER)\r\ngl_FragColor = vec4(diffuseColor.rgb, alpha);\r\n#else\r\ngl_FragColor = vec4(0.0, 0.0, 0.0, alpha);\r\n#endif\r\n\r\ngl_FragColor.a = alpha;\r\n#else\r\n#ifndef BASIC_RENDER\r\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n#else\r\ngl_FragColor = diffuseColor;\r\n#endif\r\n#endif\r\n\r\n}",
		"wood.fragment" => "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nuniform float ampScale;\r\nuniform vec3 woodColor;\r\n\r\nfloat rand(vec2 n) {\r\nreturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 n) {\r\nconst vec2 d = vec2(0.0, 1.0);\r\nvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\nfloat total = 0.0, amplitude = 1.0;\r\nfor (int i = 0; i < 4; i++) {\r\ntotal += noise(n) * amplitude;\r\nn += n;\r\namplitude *= 0.5;\r\n}\r\nreturn total;\r\n}\r\n\r\nvoid main(void) {\r\nfloat ratioy = mod(vUV.x * ampScale, 2.0 + fbm(vUV * 0.8));\r\nvec3 wood = woodColor * ratioy;\r\ngl_FragColor = vec4(wood, 1.0);\r\n}"
	];
	
}
